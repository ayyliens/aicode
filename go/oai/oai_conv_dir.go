package oai

import (
	"_/go/u"
	"log"

	"github.com/mitranim/gg"
)

const (
	BaseNameRequestTemplate = `request_template`
	BaseNameRequestLatest   = `request_latest`
	BaseNameResponseLatest  = `response_latest`
	BaseNameRequestError    = `error`
)

// Short for "OpenAI conversation directory".
type ConvDir struct {
	u.Pathed
	u.Verbose
	Messages    []ChatCompletionMessageExt
	ReqTemplate gg.Zop[ChatCompletionRequest]
	ReqLatest   gg.Zop[ChatCompletionRequest]
	ResLatest   gg.Zop[ChatCompletionResponse]
}

func (self *ConvDir) Read() {
	self.ReadRequestTemplate()
	self.ReadRequestLatest()
	self.ReadResponseLatest()
	self.ReadMessages()
}

func (self *ConvDir) ReadRequestTemplate() {
	tar := &self.ReqTemplate.Val
	u.JsonDecodeFileOpt(self.RequestTemplatePath(`.json`), tar)
	u.YamlDecodeFileOpt(self.RequestTemplatePath(`.yaml`), tar)
	u.TomlDecodeFileOpt(self.RequestTemplatePath(`.toml`), tar)
}

func (self *ConvDir) ReadRequestLatest() {
	u.PolyDecodeFileOpt(self.RequestLatestPathJson(), &self.ReqLatest.Val)
}

func (self *ConvDir) ReadResponseLatest() {
	u.PolyDecodeFileOpt(self.ResponseLatestPath(), &self.ResLatest.Val)
}

/*
TODO consider preserving file names when reading and writing messages.
File names would be a "secret" field not exposed in JSON. This would be
useful for operations that involve comparing file names, comparing paths,
etc.

TODO: instead of forbidding "holes" in message indexes, use them. When
performing a run, instead of always continuing from the last message, continue
from the last message before the first "hole". This would allow additional
potentially useful scenarios, such as:

	* Pre-create multiple "user" message files with indexes 0, 2, 4, etc.,
	  as a "dialogue framework" for a sequence of expected bot responses.

	* Deleting a message in the middle of a conversation would be a convenient way
	  to "retry"/"redo" that part of the conversation, especially when truncation
	  and/or forking is not enabled.
*/
func (self *ConvDir) ReadMessages() {
	for ind, path := range self.IndexedMessageFileNames() {
		self.ReadMessageFile(path).ValidateIndex(ind)
	}
	self.ValidateMessages()
}

func (self *ConvDir) ReadMessageFile(name string) (out IndexedMessageFileName) {
	gg.Try(out.Parse(name))
	gg.Append(&self.Messages, out.ChatCompletionMessageExt(self.PathJoin(name)))
	return
}

func (self ConvDir) IndexedMessageFileNames() []string {
	return gg.Filter(u.ReadDirFileNames(self.Path), IsIndexedMessageFileNameLax)
}

/*
Note: the last message is meant to be a placeholder for the user, and is allowed
to have empty content, so we don't validate it.
*/
func (self ConvDir) ValidateMessages() {
	for _, msg := range gg.Init(self.Messages) {
		msg.Validate()
	}
}

func (self ConvDir) RequestTemplatePath(ext string) string {
	return self.PathJoin(BaseNameRequestTemplate + ext)
}

func (self ConvDir) RequestLatestPathJson() string {
	return self.PathJoin(BaseNameRequestLatest + `.json`)
}

// Can change to any extension supported by `u.PolyEncodeFileOpt`.
func (self ConvDir) ResponseLatestPath() string {
	return self.PathJoin(BaseNameResponseLatest + `.json`)
}

func (self ConvDir) ResponseLatestPathJson() string {
	return self.PathJoin(BaseNameResponseLatest + `.json`)
}

func (self ConvDir) ErrorPath() string {
	return self.PathJoin(BaseNameRequestError + `.txt`)
}

func (self ConvDir) ForkPath() string { return u.IndexedDirForkPath(self.Path) }

/*
Side-effectful initialization.
Should be performed after `.Read`.
TODO better name.
*/
func (self *ConvDir) InitFiles(funs Functions) {
	self.EvalMessages(funs)
	self.InitNextMessagePlaceholder()
}

func (self *ConvDir) EvalMessages(funs Functions) {
	msgs := self.Messages
	last := gg.Last(msgs)
	if last.NextMessage == nil {
		return
	}

	next := *last.NextMessage
	if next.HasInternalFunctionCall() {
		next.Content = funs.Response(next.Name, next.Arguments.String(), self.Verbose)
	}

	next.Validate()
	self.WriteNextMessage(next)
}

func (self *ConvDir) InitNextMessagePlaceholder() {
	if gg.IsEmpty(self.Messages) {
		self.WriteNextMessagePlaceholder()
	}
}

func (self ConvDir) ValidMessages() []ChatCompletionMessage {
	return gg.MapCompact(self.Messages, ChatCompletionMessageExt.ValidChatCompletionMessage)
}

func (self ConvDir) ChatCompletionRequest() ChatCompletionRequest {
	tar := self.ReqTemplate.Val
	tar.Default()
	tar.Messages = self.ValidMessages()
	return tar
}

func (self ConvDir) WriteRequestLatest(src ChatCompletionRequest) {
	u.JsonEncodeFile(self.RequestLatestPathJson(), src)
}

func (self *ConvDir) WriteResponseJson(src []byte) {
	u.WriteFile(self.ResponseLatestPathJson(), u.JsonPretty(src))
}

func (self *ConvDir) WriteResponseEncoded(res ChatCompletionResponse) {
	out := self.ResponseLatestPath()

	// Assumes that `ConvDir.WriteResponseJson` is called earlier.
	// We don't want to overwrite original response JSON with JSON
	// generated by decoding and then encoding again. The original
	// has more information, such as fields not listed in our types.
	if out != self.ResponseLatestPathJson() {
		u.PolyEncodeFileOpt(out, res)
	}
}

// Intended for error paths.
func (self *ConvDir) WriteNextMessagePlaceholderOrSkip() {
	defer gg.Skip()
	self.WriteNextMessagePlaceholder()
}

func (self *ConvDir) WriteNextMessagePlaceholder() {
	var tar ChatCompletionMessageExt
	tar.Role = ChatMessageRoleUser
	self.WriteNextMessage(tar)
}

func (self *ConvDir) WriteNextMessageFunctionResponse(name FunctionName, body string) {
	var tar ChatCompletionMessageExt
	tar.Role = ChatMessageRoleFunction
	tar.Name = name
	tar.Content = body
	self.WriteNextMessage(tar)
}

func (self *ConvDir) WriteNextMessageFunctionResponsePlaceholder(src FunctionCall) {
	self.WriteNextMessageFunctionResponse(src.Name, ``)
}

func (self *ConvDir) WriteNextMessage(src ChatCompletionMessageExt) {
	ext, body := src.ExtBody()

	var tar IndexedMessageFileName
	tar.Index = self.NextIndex()
	tar.Role = src.Role
	tar.Ext = ext

	src.FileName = tar

	u.WriteFileRec(self.PathJoin(tar.ValidString()), body)
	gg.Append(&self.Messages, src)
}

func (self ConvDir) NextIndex() uint {
	return gg.NumConv[uint](len(self.Messages))
}

func (self ConvDir) LogWriteErr(err error) {
	if u.IsErrContextCancel(err) {
		return
	}

	u.LogErr(err)
	defer gg.Skip()
	self.WriteErr(err)
}

func (self ConvDir) WriteErr(err error) {
	u.FileWrite{
		Path:  self.ErrorPath(),
		Body:  gg.ToBytes(u.FormatVerbose(err)),
		Empty: u.FileWriteEmptyDelete,
	}.Run()
}

func (self ConvDir) HasIntermediateMessage(name IndexedMessageFileName) bool {
	return gg.IsNotZero(name) &&
		gg.Some(gg.Init(self.Messages), func(val ChatCompletionMessageExt) bool {
			return val.FileName == name
		})
}

func (self *ConvDir) TruncMessagesAndFilesAfterIndexedMessageFileName(name IndexedMessageFileName) {
	if !self.HasIntermediateMessage(name) {
		return
	}

	if self.Verb {
		log.Printf(`truncating messages after %q`, name)
	}

	for gg.IsNotEmpty(self.Messages) {
		msg := gg.Last(self.Messages)
		msgName := msg.FileName
		if msgName == name {
			return
		}

		if self.Verb {
			log.Printf(`removing message %q`, msgName)
		}

		u.RemoveFileOrDir(self.PathJoin(msgName.String()))
		self.Messages = gg.Init(self.Messages)
	}
}
