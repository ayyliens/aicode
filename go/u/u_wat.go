package u

import (
	"context"
	"log"
	"path/filepath"
	"time"

	"github.com/mitranim/gg"
	"github.com/rjeczalik/notify"
)

type WatcherCommon struct {
	Pathed
	Verbose
	Inited
	Ignored
	TermClearer
}

type FsEventer interface {
	OnFsEvent(Ctx, notify.EventInfo)
}

// Optional extension to `FsEventer`.
type FsEventSkipper interface {
	ShouldSkipFsEvent(notify.EventInfo) bool
}

func NotifyEventPath(eve notify.EventInfo) (_ string) {
	if eve != nil {
		return eve.Path()
	}
	return
}

/*
TODO: new FS events should kill the current call to `.Runner.OnFsEvent` by
canceling the context passed to it. There are common cases where multiple FS
events are generated almost simultaneously, for example when multiple files are
saved at once. Killing and restarting would prevent inconsistent states.
*/
type Watcher[A FsEventer] struct {
	WatcherCommon
	Runner A
	Filter notify.Event  // Allowed event types, default all.
	Delay  time.Duration // Time window for ignoring subsequent FS events.
	IsDir  bool          // `true` = dir, `false` = file.
	Create bool          // Auto-create if missing.
	events chan notify.EventInfo
}

/*
Note: defining this method on a value type, rather than a pointer type, allows
external callers to make multiple concurrent `.Run` calls on the same watcher
value, without concurrency hazards.
*/
func (self Watcher[_]) Run(ctx Ctx) {
	self.normIgnore()

	// Technical note: file events are async. At the time of writing, on the
	// author's system (MacOS), it's possible to execute FS operations, THEN
	// start watching, then receive FS events triggered by those FS operations,
	// causing an immediate rerun in our FS event loop. This may vary by OS.
	if self.ranInit(ctx) {
		self.wait(ctx)
	}

	if self.touched() {
		self.wait(ctx)
	}

	defer self.unwatch()
	self.watch()

	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			if self.Verb {
				log.Println(`[watcher] context canceled, watcher stopping`)
			}
			return

		case eve := <-self.validEventsChan():
			self.onFsEvent(ctx, eve)
		}
	}
}

func (self *Watcher[_]) unwatch() {
	tar := self.events
	if tar == nil {
		return
	}

	notify.Stop(tar)
	if self.Verb {
		log.Printf(`[watcher] unwatching %q`, self.Path)
	}
	self.events = nil
}

func (self *Watcher[_]) ranInit(ctx Ctx) bool {
	if !self.Init {
		return false
	}
	if self.Verb {
		defer gg.LogTimeNow(`[watcher] initial run`).LogStart().LogEnd()
	}
	self.Runner.OnFsEvent(ctx, nil)
	return true
}

func (self *Watcher[_]) watch() {
	self.unwatch()

	/**
	Replacing the channel, instead of reusing it, is one of our measures for
	avoiding self-triggering via events generated by `self.Runner.OnFsEvent`.
	If we stop and then watch on the same channel, the channel may receive FS
	events generated while we weren't watching. This is also why we use an
	unbuffered channel.
	*/
	self.events = make(chan notify.EventInfo)

	if self.Verb {
		log.Printf(`[watcher] watching %q`, self.Path)
	}
	gg.Try(notify.Watch(self.Pattern(), self.events, gg.Or(self.Filter, notify.All)))
}

func (self *Watcher[_]) watchDelayed(ctx Ctx) {
	self.wait(ctx)
	self.watch()
}

func (self *Watcher[_]) onFsEvent(ctx Ctx, eve notify.EventInfo) {
	if self.ShouldSkipFsEvent(eve) {
		if self.Verb {
			log.Println(`[watcher] ignoring file event:`, eve)
		}
		return
	}

	if self.Clear {
		gg.TermClearHard()
	}

	if self.Verb {
		log.Println(`[watcher] file event:`, eve)
	}

	self.unwatch()
	defer self.watch()
	// Unclear if we need a delay here.
	// defer self.watchDelayed(ctx)

	self.Runner.OnFsEvent(ctx, eve)
}

/*
This functionality is supported / provided for technical reasons. It would be
cleaner to start watching without creating the target, but if the target
doesn't exist, the watcher library returns an error. Auto-creating the target
avoids that.
*/
func (self Watcher[_]) touched() bool {
	if !self.Create {
		return false
	}

	if self.IsDir {
		if TouchedDirRec(self.Path) {
			if self.Verb {
				log.Printf(`[watcher] touched directory %q`, self.Path)
			}
			return true
		}
		return false
	}

	if TouchedFileRec(self.Path) {
		if self.Verb {
			log.Printf(`[watcher] touched file %q`, self.Path)
		}
		return true
	}
	return false
}

func (self Watcher[_]) Pattern() string {
	if gg.IsNotZero(self.Path) && self.IsDir {
		return filepath.Join(self.Path, `...`)
	}
	return self.Path
}

/*
Normalizes relative paths to absolute for compatibility with
`notify.EventInfo.Path` which returns absolute paths.
*/
func (self *Watcher[_]) normIgnore() {
	for ind, val := range self.Ignore {
		self.Ignore[ind] = gg.Try1(filepath.Abs(val))
	}
}

func (self *Watcher[_]) ShouldSkipFsEvent(eve notify.EventInfo) bool {
	if eve == nil || self.ShouldSkipPath(eve.Path()) {
		return true
	}
	impl := gg.AnyAs[FsEventSkipper](&self.Runner)
	return impl != nil && impl.ShouldSkipFsEvent(eve)
}

func (self Watcher[_]) ShouldSkipPath(path string) bool {
	return gg.Some(self.Ignore, func(val string) bool {
		return IsPathAncestorOf(val, path)
	})
}

func (self Watcher[_]) wait(ctx Ctx) {
	if self.Delay >= 0 {
		Wait(ctx, self.getDelay())
	}
}

func (self Watcher[_]) getDelay() time.Duration {
	return gg.Or(self.Delay, time.Millisecond*100)
}

// Internal sanity check. Note: in Go, listening on a nil chan blocks forever.
func (self Watcher[_]) validEventsChan() chan notify.EventInfo {
	tar := self.events
	if tar == nil {
		panic(gg.Errf(`unable to listen on nil %T`, tar))
	}
	return tar
}
